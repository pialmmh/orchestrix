# LXC Container Scaffold Template (Java-based)

## ⚠️ ALWAYS READ REQUIREMENTS.md FIRST
Every container directory has a `REQUIREMENTS.md` that defines what to build. Read it completely before creating any scripts.

## Architecture - Template Method Pattern

The Java builder system uses Template Method pattern with an abstract base class (`LXCBuilder`) that provides:
- Complete build orchestration flow
- Reusable utility methods
- Consistent error handling
- Verbose output formatting

Derived classes only implement:
- `performCustomSetup()` - Container-specific setup
- `performVerification()` - Critical component verification
- `getLaunchScriptContent()` - Runtime launch script
- `getSampleConfigContent()` - Sample configuration

## New Structure - Java-based Builder System

### Directory Structure
```
container-name/
├── REQUIREMENTS.md           # Container specifications (READ FIRST)
├── build.yaml               # Build configuration
├── CustomBuilder.java       # Optional: Custom builder extending LXCBuilder
└── container-name-v.1/      # Auto-generated by builder
    └── generated/
        ├── launch.sh
        ├── sample.conf
        ├── README-v.1.md
        └── container-name-v.1.tar.gz
```

## Step 1: Create build.yaml

```yaml
name: container-name
version: 1
base_image: debian/12
timeout: 300

packages:
  core:
    - curl
    - wget
    - git
    - vim
    - jq
  
  build:
    - make
    - gcc
    - build-essential
  
  additional:
    # Container-specific packages here

custom:
  verify: true  # Enable ExpectJ verification
  # Add container-specific settings
```

## Step 2: Create Custom Builder

All containers need a custom builder extending `LXCBuilder`:

```java
package com.orchestrix.builder.containers;

import com.orchestrix.builder.*;
import java.util.Date;

public class MyContainerBuilder extends LXCBuilder {
    
    public MyContainerBuilder(BuildConfig config) {
        super(config);
    }
    
    @Override
    protected void performCustomSetup(String buildContainer) {
        System.out.println("\nPerforming container-specific setup...");
        
        // Example: Install and configure your service
        System.out.println("  - Installing my service");
        execute("lxc exec " + buildContainer + " -- apt-get install -y my-service");
        
        // Example: Configure service
        System.out.println("  - Configuring my service");
        String config = """  
            # My service configuration
            port: 8080
            mode: production
            """;
        execute(String.format(
            "lxc exec %s -- bash -c 'cat > /etc/my-service.conf << EOF\n%s\nEOF'",
            buildContainer, config
        ));
        
        // Example: Enable service
        execute("lxc exec " + buildContainer + " -- systemctl enable my-service");
    }
    
    @Override
    protected void performVerification(String buildContainer) {
        if (!config.getCustomBoolean("verify", true)) {
            return;
        }
        
        System.out.println("\nVerifying installation...");
        
        // Verify service is installed
        executeWithVerification(
            "lxc exec " + buildContainer + " -- my-service --version",
            "MyService v",  // Expected pattern
            10              // Timeout seconds
        );
        
        System.out.println(GREEN + "  ✓ Verification passed" + RESET);
    }
    
    @Override
    protected String getLaunchScriptContent() {
        return """
            #!/bin/bash
            set -e
            
            CONFIG_FILE="${1:-$(dirname "$0")/sample.conf}"
            source "$CONFIG_FILE"
            
            # Launch from versioned image
            SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)
            VERSION_DIR=$(cd "$SCRIPT_DIR/.." && pwd)
            VERSION=$(basename "$VERSION_DIR" | cut -d. -f2)
            BASE_DIR=$(cd "$VERSION_DIR/.." && pwd)
            BASE_NAME=$(basename "$BASE_DIR")
            IMAGE_NAME="${BASE_NAME}:${VERSION}"
            
            echo "Launching container from image: ${IMAGE_NAME}"
            lxc launch ${IMAGE_NAME} ${CONTAINER_NAME}
            
            # Apply bind mounts if defined
            for mount in "${BIND_MOUNTS[@]}"; do
                lxc config device add ${CONTAINER_NAME} $(basename ${mount%%:*}) disk source=${mount%%:*} path=${mount#*:}
            done
            
            echo "Container ${CONTAINER_NAME} launched"
            """;
    }
    
    @Override
    protected String getSampleConfigContent() {
        return String.format("""
            # Runtime Configuration for %s v.%d
            CONTAINER_NAME=%s-instance-01
            
            # Bind Mounts (host:container)
            BIND_MOUNTS=(
                "/path/to/data:/data"
            )
            """, containerBase, version, containerBase);
    }
}
```

## Step 3: Build Container

Each container has its own `build.sh` wrapper that handles everything:

```bash
# From container directory
cd /home/mustafa/telcobright-projects/orchestrix/images/lxc/container-name
./build.sh                  # Interactive mode
./build.sh --overwrite     # Force mode

# Or using the build/ subdirectory
cd build
./build.sh
```

The build script automatically:
- Compiles the Java builder if needed
- Prompts for version (or uses existing)
- Runs the Java builder with proper configuration
- Generates all artifacts in container-name-v.X/generated/

## Build Process Flow

The base `LXCBuilder.build()` method orchestrates the entire build:

1. **Pre-flight Checks** (`performPreFlightChecks()`)
   - Check for running containers
   - Clean up existing images/containers

2. **Container Creation** (`createBuildContainer()`)
   - Launch base image
   - Wait for network connectivity

3. **Core Setup** (`performCoreSetup()`)
   - Update package lists
   - Install packages from build.yaml (core, build, additional)

4. **Custom Setup** (`performCustomSetup()`) - **You implement this**
   - Container-specific installations
   - Service configuration
   - Environment setup

5. **Verification** (`performVerification()`) - **You implement this**
   - Use ExpectJ to verify critical components
   - Check service availability

6. **Finalization** (`finalizeImage()`)
   - Stop container
   - Create LXC image
   - Clean up build container

7. **Artifact Generation** (`generateArtifacts()`)
   - Create launch.sh
   - Create sample.conf
   - Create README
   - Package as tar.gz

## Reusable Methods from LXCBuilder

All builders inherit these utility methods:

### Execution Methods
```java
// Simple execution with verbose output
execute("lxc exec container -- command");

// Execution with verification (ExpectJ)
executeWithVerification("command", "expected output", timeoutSeconds);
```

### Container Management
```java
// Safe deletion (no errors if doesn't exist)
safeDeleteImage("image:tag");
safeDeleteContainer("container-name");

// Check for running containers
boolean checkRunningContainers();

// Wait for network
waitForNetwork("container");
```

### Package Installation
```java
// Install with verbose output
installPackages("container", "description", "pkg1", "pkg2");
```

### Image Creation
```java
// Stop, publish, and delete build container
createImage("build-container", "image:tag");

// Generate all artifacts
generateArtifacts();
```

## Advantages of Java-based System

1. **Type Safety**: Compile-time checking prevents errors
2. **Inheritance**: Reuse common logic from base class
3. **ExpectJ Integration**: Verify only critical steps
4. **Better Error Handling**: Proper exceptions with context
5. **YAML Configuration**: Clean separation of config and logic
6. **Verbose Output**: Controlled, consistent formatting
7. **Testing**: Easy to unit test builders
8. **IDE Support**: Autocomplete, refactoring, debugging

## Adding New Container Type

1. Create directory: `images/lxc/new-container/`
2. Add `REQUIREMENTS.md` with specifications
3. Create `build.yaml` with packages
4. Create `NewContainerBuilder.java` extending `LXCBuilder`:
   - Implement `performCustomSetup()`
   - Implement `performVerification()`
   - Implement `getLaunchScriptContent()`
   - Implement `getSampleConfigContent()`
5. Add case in `BuilderCLI.createBuilder()`
6. Create `build/build.sh` (copy from template)
7. Run: `./build.sh`

## Example Implementations

### Redis Container
```java
public class RedisBuilder extends LXCBuilder {
    @Override
    protected void performCustomSetup(String buildContainer) {
        // Redis is installed via packages in build.yaml
        // Just configure it here
        System.out.println("  - Configuring Redis");
        execute(String.format(
            "lxc exec %s -- sed -i 's/^bind 127.0.0.1/bind 0.0.0.0/' /etc/redis/redis.conf",
            buildContainer
        ));
    }
    
    @Override
    protected void performVerification(String buildContainer) {
        executeWithVerification(
            "lxc exec " + buildContainer + " -- redis-server --version",
            "Redis server",
            10
        );
    }
}
```

### Database Container
```java
public class DatabaseBuilder extends LXCBuilder {
    @Override
    protected void performCustomSetup(String buildContainer) {
        System.out.println("  - Setting up PostgreSQL");
        
        // Initialize database
        execute(String.format(
            "lxc exec %s -- sudo -u postgres psql -c \"CREATE DATABASE app_db;\"",
            buildContainer
        ));
        
        // Configure for remote access
        execute(String.format(
            "lxc exec %s -- bash -c \"echo 'host all all 0.0.0.0/0 md5' >> /etc/postgresql/15/main/pg_hba.conf\"",
            buildContainer
        ));
    }
    
    @Override
    protected void performVerification(String buildContainer) {
        executeWithVerification(
            "lxc exec " + buildContainer + " -- psql --version",
            "psql (PostgreSQL) 15",
            10
        );
    }
}
```

## Migration from Shell Scripts

1. Keep existing shell scripts as reference
2. Create `build.yaml` with same parameters
3. Optionally create custom builder for complex logic
4. Test with verification enabled
5. Generated launch.sh remains compatible

## Benefits Over Shell Scripts

- **No more quoting issues**: Java handles escaping
- **No more path resolution bugs**: Use Java's Path API
- **Consistent error handling**: Try-catch with proper messages
- **Reusable components**: Extend and override as needed
- **Better debugging**: Stack traces show exact failure point
- **Parallel execution**: Easy with Java threads
- **Progress monitoring**: ExpectJ watches output patterns

## When to Use ExpectJ Verification

Use `executeWithVerification()` only for:
- Service installation confirmation
- Version checking
- Critical component availability
- Network connectivity tests

Regular commands use simple `execute()` for speed.

## Build Output Example

```
→ lxc launch images:debian/12 dev-env-build
Waiting for network connectivity...
Installing packages...
  - Installing core utilities (curl, git, vim, jq, ssh)
  - Installing build tools (gcc, make, build-essential)
  - Installing Docker
→ lxc exec dev-env-build -- docker --version [verifying]
  ✓ Verified: Docker version
Creating image: dev-env:1
✅ Build complete: dev-env:1
   Generated files in: dev-env-v.1/generated/
```