#!/bin/bash

# quarkus-scaffold.sh - Interactive generator for Quarkus LXC deployment structure
# Creates complete directory structure with build and deployment scripts

set -e

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

print_info() { echo -e "${BLUE}ℹ${NC} $1"; }
print_success() { echo -e "${GREEN}✅${NC} $1"; }
print_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
print_error() { echo -e "${RED}❌${NC} $1"; }
print_question() { echo -e "${CYAN}?${NC} $1"; }

# Get script directory
SCAFFOLD_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LXC_DIR="$(dirname "$SCAFFOLD_DIR")"

echo ""
echo "╔══════════════════════════════════════════════════════════════════╗"
echo "║                                                                  ║"
echo "║        Quarkus LXC Deployment Structure Generator               ║"
echo "║                                                                  ║"
echo "╚══════════════════════════════════════════════════════════════════╝"
echo ""

# Interactive prompts
read -p "$(print_question 'Application name (lowercase, no spaces): ')" APP_NAME
if [ -z "$APP_NAME" ]; then
    print_error "Application name is required"
    exit 1
fi

read -p "$(print_question 'Version [1.0.0]: ')" APP_VERSION
APP_VERSION=${APP_VERSION:-1.0.0}

read -p "$(print_question 'Java project path: ')" -e JAVA_PROJECT_PATH
if [ -z "$JAVA_PROJECT_PATH" ]; then
    print_error "Java project path is required"
    exit 1
fi

# Expand tilde
JAVA_PROJECT_PATH="${JAVA_PROJECT_PATH/#\~/$HOME}"

# Validate Java project path
if [ ! -d "$JAVA_PROJECT_PATH" ]; then
    print_error "Java project path not found: $JAVA_PROJECT_PATH"
    exit 1
fi

# Find JAR file
JAR_FILE=""
if [ -f "$JAVA_PROJECT_PATH/target/${APP_NAME}-${APP_VERSION}.jar" ]; then
    JAR_FILE="$JAVA_PROJECT_PATH/target/${APP_NAME}-${APP_VERSION}.jar"
else
    read -p "$(print_question 'JAR filename in target/ ['${APP_NAME}-${APP_VERSION}.jar']: ')" JAR_FILENAME
    JAR_FILENAME=${JAR_FILENAME:-${APP_NAME}-${APP_VERSION}.jar}
    JAR_FILE="$JAVA_PROJECT_PATH/target/$JAR_FILENAME"
fi

print_info "JAR file path: $JAR_FILE"

read -p "$(print_question 'Application port [7070]: ')" APP_PORT
APP_PORT=${APP_PORT:-7070}

read -p "$(print_question 'Debug port [5005]: ')" DEBUG_PORT
DEBUG_PORT=${DEBUG_PORT:-5005}

read -p "$(print_question 'JVM min heap [512m]: ')" JVM_MIN_HEAP
JVM_MIN_HEAP=${JVM_MIN_HEAP:-512m}

read -p "$(print_question 'JVM max heap [1024m]: ')" JVM_MAX_HEAP
JVM_MAX_HEAP=${JVM_MAX_HEAP:-1024m}

read -p "$(print_question 'Java version [21]: ')" JAVA_VERSION
JAVA_VERSION=${JAVA_VERSION:-21}

read -p "$(print_question 'Database name ['$APP_NAME']: ')" DB_NAME
DB_NAME=${DB_NAME:-$APP_NAME}

echo ""
print_info "Creating project structure..."
echo ""

# Create directory structure
APP_DIR="${LXC_DIR}/${APP_NAME}"
mkdir -p "$APP_DIR"
mkdir -p "$APP_DIR/build"
mkdir -p "$APP_DIR/scripts"

print_success "Directory structure created at: $APP_DIR"

# Create build.conf
print_info "Creating build.conf..."

cat > "$APP_DIR/build/build.conf" << EOF
# Build Configuration for ${APP_NAME}
# Generated by quarkus-scaffold.sh

# ============================================================================
# APPLICATION CONFIGURATION
# ============================================================================

APP_NAME="${APP_NAME}"
APP_VERSION="${APP_VERSION}"
JAVA_VERSION="${JAVA_VERSION}"

# ============================================================================
# SOURCE FILES
# ============================================================================

# Java project path
JAVA_PROJECT_PATH="${JAVA_PROJECT_PATH}"

# JAR file (will be copied from Maven build)
JAR_FILE="${JAR_FILE}"
JAR_FILENAME="$(basename $JAR_FILE)"

# ============================================================================
# LXC CONTAINER CONFIGURATION
# ============================================================================

BASE_IMAGE="debian/12"

# ============================================================================
# APPLICATION DIRECTORIES (inside container)
# ============================================================================

APP_HOME="/opt/\${APP_NAME}"
APP_DIR="\${APP_HOME}/app"
BIN_DIR="\${APP_HOME}/bin"
LOG_DIR="\${APP_HOME}/logs"
CONFIG_DIR="\${APP_HOME}/config"

# ============================================================================
# JVM CONFIGURATION
# ============================================================================

JVM_MIN_HEAP="${JVM_MIN_HEAP}"
JVM_MAX_HEAP="${JVM_MAX_HEAP}"
JVM_GC="G1GC"
JVM_MAX_GC_PAUSE="200"

# ============================================================================
# APPLICATION PORTS
# ============================================================================

APP_PORT="${APP_PORT}"
DEBUG_PORT="${DEBUG_PORT}"

# ============================================================================
# SYSTEMD SERVICE CONFIGURATION
# ============================================================================

SERVICE_NAME="\${APP_NAME}.service"
SERVICE_DESCRIPTION="\${APP_NAME} - Quarkus Application"
SERVICE_USER="root"
SERVICE_RESTART="always"
SERVICE_RESTART_SEC="10"

# ============================================================================
# DATABASE CONFIGURATION
# ============================================================================

DB_HOST="127.0.0.1"
DB_PORT="3306"
DB_NAME="${DB_NAME}"
DB_USER="root"

# ============================================================================
# BUILD OUTPUT
# ============================================================================

SCAFFOLD_DIR="$APP_DIR"
ARTIFACTS_DIR="\${SCAFFOLD_DIR}/\${APP_NAME}-v\${APP_VERSION}/generated/artifacts"
DEPLOYMENTS_DIR="\${SCAFFOLD_DIR}/\${APP_NAME}-v\${APP_VERSION}/deployments"

# ============================================================================
# ADDITIONAL SYSTEM PACKAGES
# ============================================================================

ADDITIONAL_PACKAGES="curl wget vim htop netcat-openbsd telnet"

EOF

print_success "build.conf created"

# Create build.sh
print_info "Creating build.sh..."

cat > "$APP_DIR/build/build.sh" << 'BUILDEOF'
#!/bin/bash

# build.sh - Generates LXC container image for Quarkus application

set -e

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_info() { echo -e "${BLUE}ℹ${NC} $1"; }
print_success() { echo -e "${GREEN}✅${NC} $1"; }
print_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
print_error() { echo -e "${RED}❌${NC} $1"; }

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/build.conf"

print_info "═══════════════════════════════════════════════════════════"
print_info "  Building: ${APP_NAME} v${APP_VERSION}"
print_info "═══════════════════════════════════════════════════════════"
echo ""

# Step 1: Run Maven build
print_info "Step 1: Building JAR with Maven..."
cd "$JAVA_PROJECT_PATH"
mvn clean install -DskipTests

if [ ! -f "$JAR_FILE" ]; then
    print_error "Maven build failed - JAR not found: $JAR_FILE"
    exit 1
fi

print_success "Maven build complete: $(basename $JAR_FILE)"
echo ""

# Step 2: Create output directories
print_info "Step 2: Creating output directories..."
mkdir -p "${ARTIFACTS_DIR}"
mkdir -p "${DEPLOYMENTS_DIR}"
print_success "Output directories created"
echo ""

# Step 3: Copy JAR to artifacts
print_info "Step 3: Copying JAR to artifacts..."
cp "$JAR_FILE" "${ARTIFACTS_DIR}/${JAR_FILENAME}"
print_success "JAR copied to: ${ARTIFACTS_DIR}/${JAR_FILENAME}"
echo ""

# Step 4: Create LXC container
CONTAINER_NAME="${APP_NAME}-build-temp-$$"

cleanup() {
    print_info "Cleaning up temporary container..."
    lxc delete "$CONTAINER_NAME" --force 2>/dev/null || true
}

trap cleanup EXIT

print_info "Step 4: Creating temporary LXC container..."
lxc launch "${BASE_IMAGE}" "$CONTAINER_NAME"
sleep 5
print_success "Container created: $CONTAINER_NAME"
echo ""

# Step 5: Install Java and dependencies
print_info "Step 5: Installing Java ${JAVA_VERSION} and dependencies..."
lxc exec "$CONTAINER_NAME" -- apt-get update
lxc exec "$CONTAINER_NAME" -- apt-get install -y \
    openjdk-${JAVA_VERSION}-jre-headless \
    ${ADDITIONAL_PACKAGES}
print_success "Dependencies installed"
echo ""

# Step 6: Create application directories
print_info "Step 6: Creating application directories..."
lxc exec "$CONTAINER_NAME" -- mkdir -p "${APP_DIR}"
lxc exec "$CONTAINER_NAME" -- mkdir -p "${BIN_DIR}"
lxc exec "$CONTAINER_NAME" -- mkdir -p "${LOG_DIR}"
lxc exec "$CONTAINER_NAME" -- mkdir -p "${CONFIG_DIR}"
print_success "Directories created in container"
echo ""

# Step 7: Copy JAR to container
print_info "Step 7: Copying JAR to container..."
lxc file push "${ARTIFACTS_DIR}/${JAR_FILENAME}" "${CONTAINER_NAME}${APP_DIR}/${JAR_FILENAME}"
print_success "JAR copied to container"
echo ""

# Step 8: Create startup script
print_info "Step 8: Creating startup script..."

TEMP_START_SCRIPT=$(mktemp)
cat > "$TEMP_START_SCRIPT" << 'STARTEOF'
#!/bin/bash

set -e

# Application paths
APP_HOME="__APP_HOME__"
JAR_FILE="${APP_HOME}/app/__JAR_FILENAME__"
LOG_DIR="${APP_HOME}/logs"
CONFIG_DIR="${APP_HOME}/config"

# JVM options
JVM_OPTS="-Xms__JVM_MIN_HEAP__ -Xmx__JVM_MAX_HEAP__"
JVM_OPTS="$JVM_OPTS -XX:+Use__JVM_GC__"
JVM_OPTS="$JVM_OPTS -XX:MaxGCPauseMillis=__JVM_MAX_GC_PAUSE__"
JVM_OPTS="$JVM_OPTS -XX:+HeapDumpOnOutOfMemoryError"
JVM_OPTS="$JVM_OPTS -XX:HeapDumpPath=${LOG_DIR}/heap-dump.hprof"

# Create directories
mkdir -p "$LOG_DIR"
mkdir -p "$CONFIG_DIR"

# Start application
# Quarkus will load:
# 1. Embedded application.properties (in JAR)
# 2. ${CONFIG_DIR}/application.properties (if exists - OVERRIDES embedded)
exec java $JVM_OPTS -jar "$JAR_FILE"

STARTEOF

# Replace variables
sed -i "s|__APP_HOME__|${APP_HOME}|g" "$TEMP_START_SCRIPT"
sed -i "s|__JAR_FILENAME__|${JAR_FILENAME}|g" "$TEMP_START_SCRIPT"
sed -i "s|__JVM_MIN_HEAP__|${JVM_MIN_HEAP}|g" "$TEMP_START_SCRIPT"
sed -i "s|__JVM_MAX_HEAP__|${JVM_MAX_HEAP}|g" "$TEMP_START_SCRIPT"
sed -i "s|__JVM_GC__|${JVM_GC}|g" "$TEMP_START_SCRIPT"
sed -i "s|__JVM_MAX_GC_PAUSE__|${JVM_MAX_GC_PAUSE}|g" "$TEMP_START_SCRIPT"

lxc file push "$TEMP_START_SCRIPT" "${CONTAINER_NAME}${BIN_DIR}/start.sh"
lxc exec "$CONTAINER_NAME" -- chmod +x "${BIN_DIR}/start.sh"
rm "$TEMP_START_SCRIPT"

print_success "Startup script created"
echo ""

# Step 9: Create systemd service
print_info "Step 9: Creating systemd service..."

lxc exec "$CONTAINER_NAME" -- bash -c "cat > /etc/systemd/system/${SERVICE_NAME}" << SERVICEEOF
[Unit]
Description=${SERVICE_DESCRIPTION}
After=network.target

[Service]
Type=simple
User=${SERVICE_USER}
WorkingDirectory=${APP_HOME}
ExecStart=${BIN_DIR}/start.sh
Restart=${SERVICE_RESTART}
RestartSec=${SERVICE_RESTART_SEC}
StandardOutput=journal
StandardError=journal
SyslogIdentifier=${APP_NAME}

[Install]
WantedBy=multi-user.target
SERVICEEOF

lxc exec "$CONTAINER_NAME" -- systemctl daemon-reload
print_success "Systemd service created"
echo ""

# Step 10: Stop and publish image
print_info "Step 10: Publishing LXC image..."
lxc stop "$CONTAINER_NAME"

IMAGE_ALIAS="${APP_NAME}-${APP_VERSION}"
lxc publish "$CONTAINER_NAME" --alias "$IMAGE_ALIAS" --force
print_success "Image published: $IMAGE_ALIAS"
echo ""

# Step 11: Export to tarball
print_info "Step 11: Exporting to tarball..."
TARBALL_NAME="${APP_NAME}-${APP_VERSION}.tar.gz"
cd "${ARTIFACTS_DIR}"
lxc image export "$IMAGE_ALIAS" "${TARBALL_NAME}"
print_success "Tarball created: ${TARBALL_NAME}"
echo ""

# Step 12: Generate MD5 checksum
print_info "Step 12: Generating MD5 checksum..."
md5sum "${TARBALL_NAME}" > "${TARBALL_NAME}.md5"
print_success "MD5 checksum created"
echo ""

# Step 13: Cleanup
lxc image delete "$IMAGE_ALIAS"

# Step 14: Create deployments folder structure
print_info "Step 13: Creating deployments folder structure..."
if [ ! -d "${DEPLOYMENTS_DIR}" ]; then
    mkdir -p "${DEPLOYMENTS_DIR}"
fi

# Copy new-deployment.sh to deployments folder
SCAFFOLD_SCRIPTS_DIR="${SCAFFOLD_DIR}/scripts"
if [ -f "${SCAFFOLD_SCRIPTS_DIR}/new-deployment.sh" ]; then
    cp "${SCAFFOLD_SCRIPTS_DIR}/new-deployment.sh" "${DEPLOYMENTS_DIR}/"
    chmod +x "${DEPLOYMENTS_DIR}/new-deployment.sh"
    print_success "Deployment scaffold script installed"
fi

echo ""
print_success "═══════════════════════════════════════════════════════════"
print_success "  Build Complete!"
print_success "═══════════════════════════════════════════════════════════"
echo ""
print_info "Artifacts:"
print_info "  JAR:     ${ARTIFACTS_DIR}/${JAR_FILENAME}"
print_info "  Tarball: ${ARTIFACTS_DIR}/${TARBALL_NAME}"
print_info "  MD5:     ${ARTIFACTS_DIR}/${TARBALL_NAME}.md5"
print_info "  Size:    $(du -h ${ARTIFACTS_DIR}/${TARBALL_NAME} | cut -f1)"
echo ""
print_info "Next steps:"
print_info "  1. Create deployment: cd ${DEPLOYMENTS_DIR} && ./new-deployment.sh"
print_info "  2. Deploy: ../../scripts/deploy.sh ${APP_NAME}-v${APP_VERSION}/deployments/<deployment-name>"
echo ""

BUILDEOF

chmod +x "$APP_DIR/build/build.sh"
print_success "build.sh created"

# Create new-deployment.sh template (will be copied to deployments folder by build.sh)
print_info "Creating new-deployment.sh template..."

mkdir -p "$APP_DIR/scripts"

cat > "$APP_DIR/scripts/new-deployment.sh" << 'NEWDEPEOF'
#!/bin/bash

# new-deployment.sh - Creates new deployment configuration
# Located in: <app>-v<version>/deployments/

set -e

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

print_info() { echo -e "${BLUE}ℹ${NC} $1"; }
print_success() { echo -e "${GREEN}✅${NC} $1"; }
print_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
print_error() { echo -e "${RED}❌${NC} $1"; }
print_question() { echo -e "${CYAN}?${NC} $1"; }

# Get current directory (should be deployments/)
DEPLOYMENTS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VERSION_DIR="$(dirname "$DEPLOYMENTS_DIR")"
APP_DIR="$(dirname "$VERSION_DIR")"

# Extract version and app name from path
VERSION_FOLDER=$(basename "$VERSION_DIR")
APP_NAME=$(echo "$VERSION_FOLDER" | sed 's/-v.*//')
APP_VERSION=$(echo "$VERSION_FOLDER" | sed 's/.*-v//')

# Find Java project path from build.conf
BUILD_CONF="${APP_DIR}/build/build.conf"
if [ ! -f "$BUILD_CONF" ]; then
    print_error "build.conf not found: $BUILD_CONF"
    exit 1
fi

source "$BUILD_CONF"

echo ""
echo "╔══════════════════════════════════════════════════════════════════╗"
echo "║                                                                  ║"
echo "║          Create New Deployment Configuration                     ║"
echo "║                                                                  ║"
echo "╚══════════════════════════════════════════════════════════════════╝"
echo ""
print_info "Application: ${APP_NAME} v${APP_VERSION}"
echo ""

# Interactive prompts
read -p "$(print_question 'Deployment name (e.g., link3-prod): ')" DEPLOYMENT_NAME
if [ -z "$DEPLOYMENT_NAME" ]; then
    print_error "Deployment name is required"
    exit 1
fi

DEPLOYMENT_DIR="${DEPLOYMENTS_DIR}/${DEPLOYMENT_NAME}"

if [ -d "$DEPLOYMENT_DIR" ]; then
    print_error "Deployment already exists: $DEPLOYMENT_NAME"
    exit 1
fi

# Ask if copying from previous version
COPY_FROM_PREV=""
read -p "$(print_question 'Copy from previous version deployment? [y/N]: ')" COPY_FROM_PREV

if [[ "$COPY_FROM_PREV" =~ ^[Yy]$ ]]; then
    # Find previous versions
    PREV_VERSIONS=$(find "$APP_DIR" -maxdepth 1 -type d -name "${APP_NAME}-v*" ! -name "${VERSION_FOLDER}" | sort -V)

    if [ -n "$PREV_VERSIONS" ]; then
        echo ""
        print_info "Available previous versions:"
        select prev_dir in $PREV_VERSIONS "Cancel"; do
            if [ "$prev_dir" = "Cancel" ]; then
                COPY_FROM_PREV="n"
                break
            elif [ -n "$prev_dir" ]; then
                PREV_VERSION_DIR="$prev_dir"

                # List deployments in previous version
                PREV_DEPLOYMENTS=$(find "${PREV_VERSION_DIR}/deployments" -maxdepth 1 -type d ! -path "${PREV_VERSION_DIR}/deployments" 2>/dev/null | xargs -n1 basename)

                if [ -n "$PREV_DEPLOYMENTS" ]; then
                    echo ""
                    print_info "Available deployments in $(basename $prev_dir):"
                    select prev_deploy in $PREV_DEPLOYMENTS "Cancel"; do
                        if [ "$prev_deploy" = "Cancel" ]; then
                            COPY_FROM_PREV="n"
                            break 2
                        elif [ -n "$prev_deploy" ]; then
                            PREV_DEPLOYMENT_DIR="${PREV_VERSION_DIR}/deployments/${prev_deploy}"
                            break 2
                        fi
                    done
                else
                    print_warning "No deployments found in previous version"
                    COPY_FROM_PREV="n"
                    break
                fi
            fi
        done
    else
        print_warning "No previous versions found"
        COPY_FROM_PREV="n"
    fi
fi

# Create deployment directory
mkdir -p "$DEPLOYMENT_DIR"

# If copying from previous
if [ -n "$PREV_DEPLOYMENT_DIR" ] && [ -d "$PREV_DEPLOYMENT_DIR" ]; then
    print_info "Copying configuration from: $(basename $(dirname $(dirname $PREV_DEPLOYMENT_DIR)))/deployments/$(basename $PREV_DEPLOYMENT_DIR)"

    # Copy files
    if [ -f "${PREV_DEPLOYMENT_DIR}/deployment.yaml" ]; then
        cp "${PREV_DEPLOYMENT_DIR}/deployment.yaml" "${DEPLOYMENT_DIR}/"
        # Update version in YAML
        sed -i "s/version:.*/version: ${APP_VERSION}/" "${DEPLOYMENT_DIR}/deployment.yaml"
    fi

    if [ -f "${PREV_DEPLOYMENT_DIR}/application.properties" ]; then
        cp "${PREV_DEPLOYMENT_DIR}/application.properties" "${DEPLOYMENT_DIR}/"
    fi

    print_success "Configuration copied and updated for v${APP_VERSION}"
    echo ""
    print_warning "Please review and update the configuration for version ${APP_VERSION}"
else
    # Fresh deployment - ask questions
    read -p "$(print_question 'Remote SSH host (empty for local): ')" REMOTE_HOST
    read -p "$(print_question 'Remote SSH user [ubuntu]: ')" REMOTE_USER
    REMOTE_USER=${REMOTE_USER:-ubuntu}

    read -p "$(print_question 'Container name ['${APP_NAME}-${DEPLOYMENT_NAME}']: ')" CONTAINER_NAME
    CONTAINER_NAME=${CONTAINER_NAME:-${APP_NAME}-${DEPLOYMENT_NAME}}

    read -p "$(print_question 'Container IP (with CIDR, e.g., 10.10.199.27/24) [DHCP]: ')" CONTAINER_IP

    if [ -n "$CONTAINER_IP" ]; then
        read -p "$(print_question 'Gateway [10.10.199.1]: ')" GATEWAY
        GATEWAY=${GATEWAY:-10.10.199.1}
    fi

    read -p "$(print_question 'CPU cores [2]: ')" CPU_CORES
    CPU_CORES=${CPU_CORES:-2}

    read -p "$(print_question 'Memory [2GB]: ')" MEMORY
    MEMORY=${MEMORY:-2GB}

    # Create deployment.yaml
    cat > "${DEPLOYMENT_DIR}/deployment.yaml" << EOF
# Deployment configuration for ${DEPLOYMENT_NAME}
# Application: ${APP_NAME} v${APP_VERSION}

name: ${APP_NAME}-${DEPLOYMENT_NAME}
version: ${APP_VERSION}

# Remote server configuration
remote:
  host: ${REMOTE_HOST}
  user: ${REMOTE_USER}
  use_ssh_agent: true

# Container configuration
container:
  name: ${CONTAINER_NAME}

  network:
    ip: ${CONTAINER_IP}
    gateway: ${GATEWAY}
    bridge: lxdbr0

  resources:
    cpu: ${CPU_CORES}
    memory: ${MEMORY}

# Post-deployment commands
post_deploy:
  - systemctl enable ${APP_NAME}.service
  - systemctl start ${APP_NAME}.service
  - sleep 5
  - systemctl status ${APP_NAME}.service

EOF

    # Copy application.properties from Java project
    JAVA_APP_PROPS="${JAVA_PROJECT_PATH}/src/main/resources/application.properties"

    if [ -f "$JAVA_APP_PROPS" ]; then
        print_info "Copying application.properties from Java project..."
        cp "$JAVA_APP_PROPS" "${DEPLOYMENT_DIR}/application.properties"

        # Add header
        sed -i '1i# Application properties for '${DEPLOYMENT_NAME}'\n# Customize below for this deployment\n' "${DEPLOYMENT_DIR}/application.properties"

        print_success "application.properties copied from: $JAVA_APP_PROPS"
    else
        print_warning "application.properties not found in Java project, creating template..."

        cat > "${DEPLOYMENT_DIR}/application.properties" << EOF
# Application properties for ${DEPLOYMENT_NAME}
# Customize below for this deployment

# HTTP Configuration
quarkus.http.port=7070
quarkus.http.host=0.0.0.0

# Database Configuration
quarkus.datasource.db-kind=mysql
quarkus.datasource.jdbc.url=jdbc:mysql://127.0.0.1:3306/${DB_NAME}
quarkus.datasource.username=${DB_USER}
quarkus.datasource.password=CHANGE_ME

# Connection Pool
quarkus.datasource.jdbc.max-size=20
quarkus.datasource.jdbc.min-size=5

# Logging
quarkus.log.level=INFO
quarkus.log.file.enable=true
quarkus.log.file.path=/opt/${APP_NAME}/logs/application.log

EOF
    fi
fi

# Create README
cat > "${DEPLOYMENT_DIR}/README.md" << EOF
# ${DEPLOYMENT_NAME} - ${APP_NAME} v${APP_VERSION}

## Configuration Files

- \`deployment.yaml\` - LXC container and deployment configuration
- \`application.properties\` - Quarkus application configuration (overrides JAR)

## Customize

1. Edit \`application.properties\`:
   - Update database URL, credentials
   - Adjust ports, logging, etc.

2. Edit \`deployment.yaml\` (if needed):
   - Update remote host, container name
   - Adjust resources (CPU, memory)

## Deploy

\`\`\`bash
cd ../..
./scripts/deploy.sh ${VERSION_FOLDER}/deployments/${DEPLOYMENT_NAME}
\`\`\`

## Verify

After deployment:

\`\`\`bash
# Check status
lxc exec ${CONTAINER_NAME} -- systemctl status ${APP_NAME}.service

# View logs
lxc exec ${CONTAINER_NAME} -- journalctl -u ${APP_NAME}.service -f
\`\`\`

EOF

echo ""
print_success "═══════════════════════════════════════════════════════════"
print_success "  Deployment Configuration Created!"
print_success "═══════════════════════════════════════════════════════════"
echo ""
print_info "Location: ${DEPLOYMENT_DIR}"
print_info "Files created:"
print_info "  - deployment.yaml"
print_info "  - application.properties"
print_info "  - README.md"
echo ""
print_info "Next steps:"
print_info "  1. Edit configuration:"
print_info "     vim ${DEPLOYMENT_NAME}/application.properties"
print_info "     vim ${DEPLOYMENT_NAME}/deployment.yaml"
print_info "  2. Deploy:"
print_info "     cd ../.."
print_info "     ./scripts/deploy.sh ${VERSION_FOLDER}/deployments/${DEPLOYMENT_NAME}"
echo ""

NEWDEPEOF

chmod +x "$APP_DIR/scripts/new-deployment.sh"
print_success "new-deployment.sh template created"

# Create deploy.sh
print_info "Creating deploy.sh..."

cat > "$APP_DIR/scripts/deploy.sh" << 'DEPLOYEOF'
#!/bin/bash

# deploy.sh - Deploys Quarkus application to LXC container
# Usage: ./deploy.sh <path-to-deployment-folder>

set -e

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_info() { echo -e "${BLUE}ℹ${NC} $1"; }
print_success() { echo -e "${GREEN}✅${NC} $1"; }
print_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
print_error() { echo -e "${RED}❌${NC} $1"; }

if [ $# -lt 1 ]; then
    print_error "Usage: $0 <path-to-deployment-folder>"
    echo ""
    echo "Example:"
    echo "  $0 infinite-scheduler-v1.0.0/deployments/link3-prod"
    exit 1
fi

DEPLOYMENT_PATH="$1"

if [ ! -d "$DEPLOYMENT_PATH" ]; then
    print_error "Deployment folder not found: $DEPLOYMENT_PATH"
    exit 1
fi

# Load deployment.yaml (simple YAML parser)
parse_yaml() {
    local prefix=$2
    local s='[[:space:]]*'
    local w='[a-zA-Z0-9_]*'
    local fs=$(echo @|tr @ '\034')
    sed -ne "s|^\($s\):|\1|" \
         -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
         -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p" $1 |
    awk -F$fs '{
        indent = length($1)/2;
        vname[indent] = $2;
        for (i in vname) {if (i > indent) {delete vname[i]}}
        if (length($3) > 0) {
            vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
            printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
        }
    }'
}

DEPLOYMENT_YAML="${DEPLOYMENT_PATH}/deployment.yaml"
if [ ! -f "$DEPLOYMENT_YAML" ]; then
    print_error "deployment.yaml not found in: $DEPLOYMENT_PATH"
    exit 1
fi

print_info "Loading deployment configuration..."
eval $(parse_yaml "$DEPLOYMENT_YAML" "deploy_")

# Extract version from path
VERSION_FOLDER=$(basename $(dirname "$DEPLOYMENT_PATH"))
APP_NAME=$(echo "$VERSION_FOLDER" | sed 's/-v.*//')
APP_VERSION=$(echo "$VERSION_FOLDER" | sed 's/.*-v//')

# Find artifacts
ARTIFACTS_DIR="$(dirname $(dirname $DEPLOYMENT_PATH))/generated/artifacts"
TARBALL="${ARTIFACTS_DIR}/${APP_NAME}-${APP_VERSION}.tar.gz"

if [ ! -f "$TARBALL" ]; then
    print_error "Tarball not found: $TARBALL"
    print_info "Run build.sh first"
    exit 1
fi

echo ""
print_info "═══════════════════════════════════════════════════════════"
print_info "  Deploying: ${APP_NAME} v${APP_VERSION}"
print_info "  Deployment: ${deploy_name}"
if [ -n "$deploy_remote_host" ]; then
    print_info "  Target: ${deploy_remote_host}"
else
    print_info "  Target: Local"
fi
print_info "═══════════════════════════════════════════════════════════"
echo ""

# Determine if local or remote deployment
if [ -n "$deploy_remote_host" ]; then
    REMOTE_CMD="ssh ${deploy_remote_user}@${deploy_remote_host}"
    LXC_CMD="$REMOTE_CMD lxc"
else
    LXC_CMD="lxc"
fi

# Check if container exists
print_info "Checking for existing container..."
if [ -n "$deploy_remote_host" ]; then
    CONTAINER_EXISTS=$($LXC_CMD list -c n --format csv | grep -c "^${deploy_container_name}\$" || echo "0")
else
    CONTAINER_EXISTS=$(lxc list -c n --format csv | grep -c "^${deploy_container_name}\$" || echo "0")
fi

if [ "$CONTAINER_EXISTS" != "0" ]; then
    print_warning "Container ${deploy_container_name} already exists"
    read -p "Delete and recreate? (y/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        print_info "Deleting existing container..."
        $LXC_CMD stop "${deploy_container_name}" --force
        $LXC_CMD delete "${deploy_container_name}"
        print_success "Container deleted"
    else
        print_info "Deployment cancelled"
        exit 0
    fi
fi

# Import image
IMAGE_ALIAS="${APP_NAME}-${APP_VERSION}"
print_info "Importing image..."

if [ -n "$deploy_remote_host" ]; then
    # Remote deployment - copy tarball
    print_info "Copying tarball to remote host..."
    scp "$TARBALL" "${deploy_remote_user}@${deploy_remote_host}:/tmp/${APP_NAME}-${APP_VERSION}.tar.gz"
    $REMOTE_CMD "lxc image import /tmp/${APP_NAME}-${APP_VERSION}.tar.gz --alias ${IMAGE_ALIAS} && rm /tmp/${APP_NAME}-${APP_VERSION}.tar.gz"
else
    # Local deployment
    lxc image import "$TARBALL" --alias "$IMAGE_ALIAS"
fi

print_success "Image imported: $IMAGE_ALIAS"

# Create container
print_info "Creating container: ${deploy_container_name}..."
$LXC_CMD launch "$IMAGE_ALIAS" "${deploy_container_name}"
sleep 5
print_success "Container created"

# Configure network if specified
if [ -n "$deploy_container_network_ip" ]; then
    print_info "Configuring static IP: ${deploy_container_network_ip}..."

    IP="${deploy_container_network_ip%/*}"
    NETMASK="${deploy_container_network_ip##*/}"
    GATEWAY="${deploy_container_network_gateway}"

    $LXC_CMD exec "${deploy_container_name}" -- bash -c "cat > /etc/network/interfaces.d/eth0 <<EOF
auto eth0
iface eth0 inet static
    address $IP/$NETMASK
    gateway $GATEWAY
EOF
systemctl restart networking
"
    print_success "Network configured"
fi

# Set resource limits
if [ -n "$deploy_container_resources_cpu" ]; then
    print_info "Setting CPU limit: ${deploy_container_resources_cpu}"
    $LXC_CMD config set "${deploy_container_name}" limits.cpu "${deploy_container_resources_cpu}"
fi

if [ -n "$deploy_container_resources_memory" ]; then
    print_info "Setting memory limit: ${deploy_container_resources_memory}"
    $LXC_CMD config set "${deploy_container_name}" limits.memory "${deploy_container_resources_memory}"
fi

# Inject application.properties
APP_PROPS="${DEPLOYMENT_PATH}/application.properties"
if [ -f "$APP_PROPS" ]; then
    print_info "Injecting deployment-specific application.properties..."

    if [ -n "$deploy_remote_host" ]; then
        # Copy to remote first, then to container
        scp "$APP_PROPS" "${deploy_remote_user}@${deploy_remote_host}:/tmp/application.properties"
        $REMOTE_CMD "lxc file push /tmp/application.properties ${deploy_container_name}/opt/${APP_NAME}/config/application.properties && rm /tmp/application.properties"
    else
        lxc file push "$APP_PROPS" "${deploy_container_name}/opt/${APP_NAME}/config/application.properties"
    fi

    print_success "application.properties injected (will override JAR defaults)"
fi

# Run post-deployment commands
if [ -n "$deploy_post_deploy" ]; then
    print_info "Running post-deployment commands..."
    $LXC_CMD exec "${deploy_container_name}" -- systemctl enable "${APP_NAME}.service"
    $LXC_CMD exec "${deploy_container_name}" -- systemctl start "${APP_NAME}.service"
    sleep 5

    SERVICE_STATUS=$($LXC_CMD exec "${deploy_container_name}" -- systemctl is-active "${APP_NAME}.service" || echo "inactive")

    if [ "$SERVICE_STATUS" = "active" ]; then
        print_success "Service is running"
    else
        print_warning "Service status: $SERVICE_STATUS"
    fi
fi

# Cleanup image
$LXC_CMD image delete "$IMAGE_ALIAS" || true

echo ""
print_success "═══════════════════════════════════════════════════════════"
print_success "  Deployment Complete!"
print_success "═══════════════════════════════════════════════════════════"
echo ""
print_info "Container: ${deploy_container_name}"
if [ -n "$deploy_container_network_ip" ]; then
    print_info "IP: ${deploy_container_network_ip%/*}"
fi
echo ""
print_info "Useful commands:"
echo ""

if [ -n "$deploy_remote_host" ]; then
    print_info "Check status:"
    echo "  ssh ${deploy_remote_user}@${deploy_remote_host} 'lxc exec ${deploy_container_name} -- systemctl status ${APP_NAME}.service'"
    echo ""
    print_info "View logs:"
    echo "  ssh ${deploy_remote_user}@${deploy_remote_host} 'lxc exec ${deploy_container_name} -- journalctl -u ${APP_NAME}.service -f'"
else
    print_info "Check status:"
    echo "  lxc exec ${deploy_container_name} -- systemctl status ${APP_NAME}.service"
    echo ""
    print_info "View logs:"
    echo "  lxc exec ${deploy_container_name} -- journalctl -u ${APP_NAME}.service -f"
fi

echo ""

DEPLOYEOF

chmod +x "$APP_DIR/scripts/deploy.sh"
print_success "deploy.sh created"

# Create README
print_info "Creating README.md..."

cat > "$APP_DIR/README.md" << EOF
# ${APP_NAME} - LXC Deployment

Generated by quarkus-scaffold.sh

## Directory Structure

\`\`\`
${APP_NAME}/
├── build/
│   ├── build.conf                    # Build configuration
│   └── build.sh                      # Build script (Maven + LXC image)
│
├── scripts/
│   ├── deploy.sh                     # Deployment script
│   └── new-deployment.sh             # Template (copied to deployments/)
│
└── ${APP_NAME}-v{version}/           # Version-specific artifacts
    ├── generated/
    │   └── artifacts/
    │       ├── ${APP_NAME}-{version}.jar
    │       └── ${APP_NAME}-{version}.tar.gz
    │
    └── deployments/                  # Version-specific deployments
        ├── new-deployment.sh         # Create new deployment
        ├── link3-prod/
        │   ├── deployment.yaml
        │   └── application.properties
        └── link3-staging/
            ├── deployment.yaml
            └── application.properties
\`\`\`

## Workflow

### 1. Build (Creates JAR + LXC Image)

\`\`\`bash
cd build
./build.sh
\`\`\`

This will:
- Run \`mvn clean install -DskipTests\`
- Copy JAR to artifacts/
- Create LXC container image
- Export to tarball

Output: \`${APP_NAME}-v${APP_VERSION}/generated/artifacts/\`

### 2. Create Deployment Configuration

\`\`\`bash
cd ${APP_NAME}-v${APP_VERSION}/deployments
./new-deployment.sh
\`\`\`

Interactive prompts will create:
- \`deployment.yaml\` - Container configuration
- \`application.properties\` - Quarkus config (copied from Java project)

### 3. Customize Configuration

Edit the deployment-specific files:

\`\`\`bash
vim <deployment-name>/application.properties
vim <deployment-name>/deployment.yaml
\`\`\`

### 4. Deploy

\`\`\`bash
cd ../..
./scripts/deploy.sh ${APP_NAME}-v${APP_VERSION}/deployments/<deployment-name>
\`\`\`

## Multiple Versions

Build multiple versions:

\`\`\`bash
# Edit build.conf for v1.1.0
vim build/build.conf
# Update: APP_VERSION="1.1.0"
#         JAR_FILE=".../target/${APP_NAME}-1.1.0.jar"

# Build v1.1.0
cd build && ./build.sh

# Create v1.1.0 deployment
cd ../${APP_NAME}-v1.1.0/deployments
./new-deployment.sh
# Can copy from v1.0.0 deployment!

# Deploy v1.1.0
../../scripts/deploy.sh ${APP_NAME}-v1.1.0/deployments/link3-prod-v1.1
\`\`\`

## Configuration Override

Quarkus loads configuration in this order:

1. **Embedded** \`application.properties\` (in JAR) - Default values
2. **/opt/${APP_NAME}/config/application.properties** - Deployment-specific (OVERRIDES embedded)

The deployment script injects step 2, allowing same JAR for multiple environments.

## Key Features

✅ **One build, multiple deployments** - Same JAR, different configs
✅ **Version-specific deployments** - Each version has separate deployment folders
✅ **Config override** - Deployment properties override JAR defaults
✅ **Maven integration** - build.sh runs mvn clean install
✅ **Local or remote** - Deploy to local LXC or remote servers
✅ **Copy between versions** - Migrate configs from v1.0.0 to v1.1.0

EOF

print_success "README.md created"

echo ""
print_success "═══════════════════════════════════════════════════════════"
print_success "  Scaffold Complete!"
print_success "═══════════════════════════════════════════════════════════"
echo ""
print_info "Application: ${APP_NAME}"
print_info "Location: ${APP_DIR}"
echo ""
print_info "Next steps:"
echo ""
print_info "1. Review build configuration:"
echo "   vim ${APP_DIR}/build/build.conf"
echo ""
print_info "2. Build LXC image:"
echo "   cd ${APP_DIR}/build && ./build.sh"
echo ""
print_info "3. Create deployment:"
echo "   cd ${APP_DIR}/${APP_NAME}-v${APP_VERSION}/deployments"
echo "   ./new-deployment.sh"
echo ""
print_info "4. Deploy:"
echo "   cd ${APP_DIR}"
echo "   ./scripts/deploy.sh ${APP_NAME}-v${APP_VERSION}/deployments/<name>"
echo ""
print_info "For full documentation:"
echo "   cat ${APP_DIR}/README.md"
echo ""

