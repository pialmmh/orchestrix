package com.telcobright.orchestrix.automation.api.container.lxc.app.goid.scripts;

/**
 * Complete Go ID Generator Service Code
 *
 * <p>Full REST API matching Node.js unique-id-generator:
 * <ul>
 *   <li>GET /api/next-id/:entityName?dataType={type} - Single ID</li>
 *   <li>GET /api/next-batch/:entityName?dataType={type}&batchSize={n} - Batch IDs</li>
 *   <li>GET /api/status/:entityName - Entity status</li>
 *   <li>POST /api/init/:entityName - Initialize entity</li>
 *   <li>PUT /api/reset/:entityName - Reset counter</li>
 *   <li>GET /api/list - List entities</li>
 *   <li>GET /api/types - Available types</li>
 *   <li>GET /api/parse-snowflake/:id - Parse Snowflake ID</li>
 *   <li>GET /health - Health check</li>
 *   <li>GET /shard-info - Shard info</li>
 * </ul>
 */
public class GoIdServiceCode {

    private final int servicePort;

    public GoIdServiceCode(int servicePort) {
        this.servicePort = servicePort;
    }

    /**
     * Get complete Go service source code
     */
    public String getServiceCode() {
        return String.join("\n",
                "package main",
                "",
                "import (",
                "    \"encoding/json\"",
                "    \"fmt\"",
                "    \"io/ioutil\"",
                "    \"log\"",
                "    \"net/http\"",
                "    \"os\"",
                "    \"os/signal\"",
                "    \"strconv\"",
                "    \"strings\"",
                "    \"syscall\"",
                "    \"time\"",
                "    \"crypto/rand\"",
                "    \"math/big\"",
                "    \"context\"",
                "",
                "    \"github.com/gorilla/mux\"",
                "    \"github.com/sony/sonyflake\"",
                "    consulapi \"github.com/hashicorp/consul/api\"",
                ")",
                "",
                "// Data types",
                "const (",
                "    DataTypeInt       = \"int\"",
                "    DataTypeLong      = \"long\"",
                "    DataTypeSnowflake = \"snowflake\"",
                "    DataTypeUUID8     = \"uuid8\"",
                "    DataTypeUUID12    = \"uuid12\"",
                "    DataTypeUUID16    = \"uuid16\"",
                "    DataTypeUUID22    = \"uuid22\"",
                ")",
                "",
                "const (",
                "    MaxInt  = 2147483647",
                "    MaxLong = 9223372036854775807",
                ")",
                "",
                "// EntityRecord represents state for an entity",
                "type EntityRecord struct {",
                "    EntityName       string `json:\"entityName\"`",
                "    DataType         string `json:\"dataType\"`",
                "    CurrentIteration int64  `json:\"currentIteration\"`",
                "    ShardID          int    `json:\"shardId\"`",
                "}",
                "",
                "// Global state",
                "var (",
                "    sf          *sonyflake.Sonyflake",
                "    state       []EntityRecord",
                "    shardID     int",
                "    totalShards int",
                "    dataDir     = \"/var/lib/go-id\"",
                "    stateFile   = dataDir + \"/state.json\"",
                ")",
                "",
                "// Get shard ID from environment",
                "func getShardID() int {",
                "    if s := os.Getenv(\"SHARD_ID\"); s != \"\" {",
                "        if id, err := strconv.Atoi(s); err == nil && id > 0 && id < 65536 {",
                "            return id",
                "        }",
                "        log.Printf(\"WARNING: Invalid SHARD_ID=%s. Using default=1\", s)",
                "    }",
                "    log.Println(\"WARNING: SHARD_ID not set. Using default=1\")",
                "    return 1",
                "}",
                "",
                "// Get total shards from environment",
                "func getTotalShards() int {",
                "    if s := os.Getenv(\"TOTAL_SHARDS\"); s != \"\" {",
                "        if total, err := strconv.Atoi(s); err == nil && total > 0 {",
                "            return total",
                "        }",
                "    }",
                "    return 1",
                "}",
                "",
                "// Get Consul URL from environment",
                "func getConsulURL() string {",
                "    if url := os.Getenv(\"CONSUL_URL\"); url != \"\" {",
                "        return url",
                "    }",
                "    return \"\"  // Consul disabled if not set",
                "}",
                "",
                "// Get service name from environment",
                "func getServiceName() string {",
                "    if name := os.Getenv(\"SERVICE_NAME\"); name != \"\" {",
                "        return name",
                "    }",
                "    return \"go-id\"",
                "}",
                "",
                "// Get container IP from environment",
                "func getContainerIP() string {",
                "    if ip := os.Getenv(\"CONTAINER_IP\"); ip != \"\" {",
                "        return ip",
                "    }",
                "    return \"127.0.0.1\"",
                "}",
                "",
                "// Register service with Consul",
                "func registerWithConsul(consulURL, serviceName, serviceID, containerIP string, port int) (*consulapi.Client, error) {",
                "    config := consulapi.DefaultConfig()",
                "    config.Address = consulURL",
                "",
                "    client, err := consulapi.NewClient(config)",
                "    if err != nil {",
                "        return nil, fmt.Errorf(\"failed to create consul client: %v\", err)",
                "    }",
                "",
                "    registration := &consulapi.AgentServiceRegistration{",
                "        ID:      serviceID,",
                "        Name:    serviceName,",
                "        Port:    port,",
                "        Address: containerIP,",
                "        Tags:    []string{fmt.Sprintf(\"shard-%d\", shardID), fmt.Sprintf(\"v%d\", 1)},",
                "        Meta: map[string]string{",
                "            \"shard_id\":     fmt.Sprintf(\"%d\", shardID),",
                "            \"total_shards\": fmt.Sprintf(\"%d\", totalShards),",
                "        },",
                "        Check: &consulapi.AgentServiceCheck{",
                "            HTTP:                           fmt.Sprintf(\"http://%s:%d/health\", containerIP, port),",
                "            Interval:                       \"10s\",",
                "            Timeout:                        \"5s\",",
                "            DeregisterCriticalServiceAfter: \"1m\",",
                "        },",
                "    }",
                "",
                "    if err := client.Agent().ServiceRegister(registration); err != nil {",
                "        return nil, fmt.Errorf(\"failed to register service: %v\", err)",
                "    }",
                "",
                "    log.Printf(\"✓ Registered with Consul: %s (ID: %s, IP: %s:%d)\", serviceName, serviceID, containerIP, port)",
                "    return client, nil",
                "}",
                "",
                "// Deregister service from Consul",
                "func deregisterFromConsul(client *consulapi.Client, serviceID string) {",
                "    if client == nil {",
                "        return",
                "    }",
                "    if err := client.Agent().ServiceDeregister(serviceID); err != nil {",
                "        log.Printf(\"Error deregistering from Consul: %v\", err)",
                "    } else {",
                "        log.Printf(\"✓ Deregistered from Consul: %s\", serviceID)",
                "    }",
                "}",
                "",
                "// Calculate next sharded value (interleaved)",
                "func getNextShardedValue(iteration int64) int64 {",
                "    return int64(shardID) + (iteration * int64(totalShards))",
                "}",
                "",
                "// Calculate iteration from value",
                "func getIterationFromValue(value int64) int64 {",
                "    return (value - int64(shardID)) / int64(totalShards)",
                "}",
                "",
                "// Generate UUID with specified length",
                "func generateUUID(length int) string {",
                "    const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"",
                "    result := make([]byte, length)",
                "    for i := 0; i < length; i++ {",
                "        n, _ := rand.Int(rand.Reader, big.NewInt(int64(len(chars))))",
                "        result[i] = chars[n.Int64()]",
                "    }",
                "    return string(result)",
                "}",
                "",
                "// Load state from file",
                "func loadState() error {",
                "    if _, err := os.Stat(stateFile); os.IsNotExist(err) {",
                "        state = []EntityRecord{}",
                "        return nil",
                "    }",
                "",
                "    data, err := ioutil.ReadFile(stateFile)",
                "    if err != nil {",
                "        return err",
                "    }",
                "",
                "    return json.Unmarshal(data, &state)",
                "}",
                "",
                "// Save state to file",
                "func saveState() error {",
                "    os.MkdirAll(dataDir, 0755)",
                "    data, err := json.MarshalIndent(state, \"\", \"  \")",
                "    if err != nil {",
                "        return err",
                "    }",
                "    return ioutil.WriteFile(stateFile, data, 0644)",
                "}",
                "",
                "// Find entity by name",
                "func findEntity(entityName string) *EntityRecord {",
                "    for i := range state {",
                "        if state[i].EntityName == entityName {",
                "            return &state[i]",
                "        }",
                "    }",
                "    return nil",
                "}",
                "",
                "// API Handlers",
                "",
                "func shardInfoHandler(w http.ResponseWriter, r *http.Request) {",
                "    json.NewEncoder(w).Encode(map[string]interface{}{",
                "        \"shardId\":     shardID,",
                "        \"totalShards\": totalShards,",
                "        \"status\":      \"active\",",
                "    })",
                "}",
                "",
                "func healthHandler(w http.ResponseWriter, r *http.Request) {",
                "    json.NewEncoder(w).Encode(map[string]interface{}{",
                "        \"status\":      \"healthy\",",
                "        \"shard\":       shardID,",
                "        \"totalShards\": totalShards,",
                "    })",
                "}",
                "",
                "func nextIdHandler(w http.ResponseWriter, r *http.Request) {",
                "    vars := mux.Vars(r)",
                "    entityName := vars[\"entityName\"]",
                "    dataType := r.URL.Query().Get(\"dataType\")",
                "",
                "    if entityName == \"\" {",
                "        http.Error(w, \"Entity name is required\", http.StatusBadRequest)",
                "        return",
                "    }",
                "",
                "    if dataType == \"\" {",
                "        http.Error(w, \"dataType query parameter is required\", http.StatusBadRequest)",
                "        return",
                "    }",
                "",
                "    record := findEntity(entityName)",
                "    if record == nil {",
                "        record = &EntityRecord{",
                "            EntityName:       entityName,",
                "            DataType:         dataType,",
                "            CurrentIteration: 0,",
                "            ShardID:          shardID,",
                "        }",
                "        state = append(state, *record)",
                "    } else if record.DataType != dataType {",
                "        http.Error(w, fmt.Sprintf(\"Type mismatch: entity '%s' is registered as '%s'\", entityName, record.DataType), http.StatusBadRequest)",
                "        return",
                "    }",
                "",
                "    var nextValue interface{}",
                "",
                "    switch dataType {",
                "    case DataTypeSnowflake:",
                "        id, err := sf.NextID()",
                "        if err != nil {",
                "            http.Error(w, err.Error(), http.StatusInternalServerError)",
                "            return",
                "        }",
                "        nextValue = id",
                "",
                "    case DataTypeUUID8, DataTypeUUID12, DataTypeUUID16, DataTypeUUID22:",
                "        length, _ := strconv.Atoi(strings.TrimPrefix(dataType, \"uuid\"))",
                "        nextValue = generateUUID(length)",
                "",
                "    case DataTypeInt, DataTypeLong:",
                "        val := getNextShardedValue(record.CurrentIteration)",
                "        if dataType == DataTypeInt && val > MaxInt {",
                "            http.Error(w, \"Integer overflow\", http.StatusInternalServerError)",
                "            return",
                "        }",
                "        if dataType == DataTypeLong && val > MaxLong {",
                "            http.Error(w, \"Long overflow\", http.StatusInternalServerError)",
                "            return",
                "        }",
                "        nextValue = val",
                "        record.CurrentIteration++",
                "        // Update record in state",
                "        for i := range state {",
                "            if state[i].EntityName == entityName {",
                "                state[i].CurrentIteration = record.CurrentIteration",
                "                break",
                "            }",
                "        }",
                "",
                "    default:",
                "        http.Error(w, \"Invalid dataType\", http.StatusBadRequest)",
                "        return",
                "    }",
                "",
                "    saveState()",
                "",
                "    json.NewEncoder(w).Encode(map[string]interface{}{",
                "        \"entityName\": entityName,",
                "        \"dataType\":   dataType,",
                "        \"value\":      nextValue,",
                "        \"shard\":      shardID,",
                "    })",
                "}",
                "",
                "func nextBatchHandler(w http.ResponseWriter, r *http.Request) {",
                "    vars := mux.Vars(r)",
                "    entityName := vars[\"entityName\"]",
                "    dataType := r.URL.Query().Get(\"dataType\")",
                "    batchSizeStr := r.URL.Query().Get(\"batchSize\")",
                "",
                "    batchSize, err := strconv.Atoi(batchSizeStr)",
                "    if err != nil || batchSize < 1 || batchSize > 10000 {",
                "        http.Error(w, \"batchSize must be between 1 and 10000\", http.StatusBadRequest)",
                "        return",
                "    }",
                "",
                "    if dataType == DataTypeSnowflake {",
                "        values := make([]uint64, batchSize)",
                "        for i := 0; i < batchSize; i++ {",
                "            id, _ := sf.NextID()",
                "            values[i] = id",
                "        }",
                "        json.NewEncoder(w).Encode(map[string]interface{}{",
                "            \"entityName\": entityName,",
                "            \"dataType\":   dataType,",
                "            \"batchSize\":  batchSize,",
                "            \"values\":     values,",
                "            \"shard\":      shardID,",
                "        })",
                "        return",
                "    }",
                "",
                "    if strings.HasPrefix(dataType, \"uuid\") {",
                "        length, _ := strconv.Atoi(strings.TrimPrefix(dataType, \"uuid\"))",
                "        values := make([]string, batchSize)",
                "        for i := 0; i < batchSize; i++ {",
                "            values[i] = generateUUID(length)",
                "        }",
                "        json.NewEncoder(w).Encode(map[string]interface{}{",
                "            \"entityName\": entityName,",
                "            \"dataType\":   dataType,",
                "            \"batchSize\":  batchSize,",
                "            \"values\":     values,",
                "            \"shard\":      shardID,",
                "        })",
                "        return",
                "    }",
                "",
                "    // Numeric types",
                "    record := findEntity(entityName)",
                "    if record == nil {",
                "        record = &EntityRecord{",
                "            EntityName:       entityName,",
                "            DataType:         dataType,",
                "            CurrentIteration: 0,",
                "            ShardID:          shardID,",
                "        }",
                "        state = append(state, *record)",
                "    }",
                "",
                "    values := make([]int64, batchSize)",
                "    for i := 0; i < batchSize; i++ {",
                "        val := getNextShardedValue(record.CurrentIteration + int64(i))",
                "        values[i] = val",
                "    }",
                "",
                "    record.CurrentIteration += int64(batchSize)",
                "    // Update in state",
                "    for i := range state {",
                "        if state[i].EntityName == entityName {",
                "            state[i].CurrentIteration = record.CurrentIteration",
                "            break",
                "        }",
                "    }",
                "",
                "    saveState()",
                "",
                "    json.NewEncoder(w).Encode(map[string]interface{}{",
                "        \"entityName\": entityName,",
                "        \"dataType\":   dataType,",
                "        \"batchSize\":  len(values),",
                "        \"startValue\": values[0],",
                "        \"endValue\":   values[len(values)-1],",
                "        \"values\":     values,",
                "        \"shard\":      shardID,",
                "    })",
                "}",
                "",
                "func statusHandler(w http.ResponseWriter, r *http.Request) {",
                "    vars := mux.Vars(r)",
                "    entityName := vars[\"entityName\"]",
                "",
                "    record := findEntity(entityName)",
                "    if record == nil {",
                "        http.Error(w, \"Entity not found\", http.StatusNotFound)",
                "        return",
                "    }",
                "",
                "    var currentValue interface{}",
                "    if record.DataType == DataTypeSnowflake {",
                "        currentValue = \"N/A (Snowflake IDs)\"",
                "    } else if !strings.HasPrefix(record.DataType, \"uuid\") && record.CurrentIteration > 0 {",
                "        currentValue = getNextShardedValue(record.CurrentIteration - 1)",
                "    }",
                "",
                "    json.NewEncoder(w).Encode(map[string]interface{}{",
                "        \"entityName\":       record.EntityName,",
                "        \"dataType\":         record.DataType,",
                "        \"currentValue\":     currentValue,",
                "        \"currentIteration\": record.CurrentIteration,",
                "        \"shard\":            shardID,",
                "        \"nextValue\":        getNextShardedValue(record.CurrentIteration),",
                "    })",
                "}",
                "",
                "func listHandler(w http.ResponseWriter, r *http.Request) {",
                "    entities := make([]map[string]interface{}, len(state))",
                "    for i, record := range state {",
                "        var currentValue interface{}",
                "        if record.DataType == DataTypeSnowflake {",
                "            currentValue = \"N/A\"",
                "        } else if !strings.HasPrefix(record.DataType, \"uuid\") && record.CurrentIteration > 0 {",
                "            currentValue = getNextShardedValue(record.CurrentIteration - 1)",
                "        }",
                "",
                "        entities[i] = map[string]interface{}{",
                "            \"entityName\":       record.EntityName,",
                "            \"dataType\":         record.DataType,",
                "            \"currentValue\":     currentValue,",
                "            \"currentIteration\": record.CurrentIteration,",
                "            \"shard\":            shardID,",
                "        }",
                "    }",
                "",
                "    json.NewEncoder(w).Encode(map[string]interface{}{",
                "        \"entities\": entities,",
                "        \"shardInfo\": map[string]int{",
                "            \"shardId\":     shardID,",
                "            \"totalShards\": totalShards,",
                "        },",
                "    })",
                "}",
                "",
                "func typesHandler(w http.ResponseWriter, r *http.Request) {",
                "    json.NewEncoder(w).Encode(map[string]interface{}{",
                "        \"availableTypes\": []string{\"int\", \"long\", \"snowflake\", \"uuid8\", \"uuid12\", \"uuid16\", \"uuid22\"},",
                "        \"description\": map[string]string{",
                "            \"int\":       fmt.Sprintf(\"32-bit sequential (shard %d: %d, %d, %d...)\", shardID, shardID, shardID+totalShards, shardID+2*totalShards),",
                "            \"long\":      fmt.Sprintf(\"64-bit sequential (shard %d: %d, %d, %d...)\", shardID, shardID, shardID+totalShards, shardID+2*totalShards),",
                "            \"snowflake\": \"64-bit time-ordered unique ID (Sonyflake)\",",
                "            \"uuid8\":     \"Random 8-char string (legacy)\",",
                "            \"uuid12\":    \"Random 12-char string (legacy)\",",
                "            \"uuid16\":    \"Random 16-char string (legacy)\",",
                "            \"uuid22\":    \"Random 22-char string (legacy)\",",
                "        },",
                "        \"shardInfo\": map[string]int{",
                "            \"shardId\":     shardID,",
                "            \"totalShards\": totalShards,",
                "        },",
                "    })",
                "}",
                "",
                "func main() {",
                "    shardID = getShardID()",
                "    totalShards = getTotalShards()",
                "",
                "    log.Printf(\"Starting Go ID Generator - Shard %d of %d\", shardID, totalShards)",
                "",
                "    // Initialize Sonyflake",
                "    settings := sonyflake.Settings{",
                "        StartTime: time.Date(2022, 1, 1, 0, 0, 0, 0, time.UTC),",
                "        MachineID: func() (uint16, error) {",
                "            return uint16(shardID), nil",
                "        },",
                "    }",
                "    sf = sonyflake.NewSonyflake(settings)",
                "    if sf == nil {",
                "        log.Fatal(\"Failed to initialize Sonyflake\")",
                "    }",
                "",
                "    // Load state",
                "    if err := loadState(); err != nil {",
                "        log.Printf(\"Error loading state: %v\", err)",
                "    }",
                "",
                "    // Get configuration",
                "    port := \"" + servicePort + "\"",
                "    portInt, _ := strconv.Atoi(port)",
                "    consulURL := getConsulURL()",
                "    serviceName := getServiceName()",
                "    containerIP := getContainerIP()",
                "    serviceID := fmt.Sprintf(\"%s-shard-%d\", serviceName, shardID)",
                "",
                "    // Register with Consul if URL provided",
                "    var consulClient *consulapi.Client",
                "    if consulURL != \"\" {",
                "        client, err := registerWithConsul(consulURL, serviceName, serviceID, containerIP, portInt)",
                "        if err != nil {",
                "            log.Printf(\"WARNING: Consul registration failed: %v\", err)",
                "            log.Printf(\"Continuing without Consul...\")",
                "        } else {",
                "            consulClient = client",
                "        }",
                "    } else {",
                "        log.Printf(\"Consul URL not set - running without service discovery\")",
                "    }",
                "",
                "    // Setup graceful shutdown",
                "    stop := make(chan os.Signal, 1)",
                "    signal.Notify(stop, os.Interrupt, syscall.SIGTERM)",
                "",
                "    // Setup router",
                "    r := mux.NewRouter()",
                "    r.HandleFunc(\"/shard-info\", shardInfoHandler).Methods(\"GET\")",
                "    r.HandleFunc(\"/health\", healthHandler).Methods(\"GET\")",
                "    r.HandleFunc(\"/api/next-id/{entityName}\", nextIdHandler).Methods(\"GET\")",
                "    r.HandleFunc(\"/api/next-batch/{entityName}\", nextBatchHandler).Methods(\"GET\")",
                "    r.HandleFunc(\"/api/status/{entityName}\", statusHandler).Methods(\"GET\")",
                "    r.HandleFunc(\"/api/list\", listHandler).Methods(\"GET\")",
                "    r.HandleFunc(\"/api/types\", typesHandler).Methods(\"GET\")",
                "",
                "    // Set JSON content type",
                "    r.Use(func(next http.Handler) http.Handler {",
                "        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {",
                "            w.Header().Set(\"Content-Type\", \"application/json\")",
                "            next.ServeHTTP(w, r)",
                "        })",
                "    })",
                "",
                "    // Start HTTP server",
                "    srv := &http.Server{",
                "        Addr:    \":\" + port,",
                "        Handler: r,",
                "    }",
                "",
                "    go func() {",
                "        log.Printf(\"Listening on port %s\", port)",
                "        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {",
                "            log.Fatalf(\"Server error: %v\", err)",
                "        }",
                "    }()",
                "",
                "    // Wait for interrupt signal",
                "    <-stop",
                "",
                "    // Graceful shutdown",
                "    log.Printf(\"Shutting down gracefully...\")",
                "",
                "    // Deregister from Consul",
                "    if consulClient != nil {",
                "        deregisterFromConsul(consulClient, serviceID)",
                "    }",
                "",
                "    // Shutdown HTTP server",
                "    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)",
                "    defer cancel()",
                "    if err := srv.Shutdown(ctx); err != nil {",
                "        log.Printf(\"Server shutdown error: %v\", err)",
                "    }",
                "",
                "    log.Printf(\"Service stopped\")",
                "}"
        );
    }
}
