#!/usr/bin/env python3

"""
Create Jenkins Job for LXD Container Builder
This script creates the Jenkins Pipeline job programmatically
"""

import requests
import yaml
import sys
import os
from xml.etree import ElementTree as ET

class JenkinsJobCreator:
    def __init__(self, config_file: str = "jenkins-config.yml"):
        """Initialize with Jenkins configuration"""
        self.config = self.load_config(config_file)
        self.jenkins_url = self.config['jenkins']['server']['url']
        self.job_name = self.config['jenkins']['server']['job_name']
        self.username = self.config['jenkins']['auth']['username']
        self.api_token = self.config['jenkins']['auth']['api_token']
        
    def load_config(self, config_file: str) -> dict:
        """Load Jenkins configuration"""
        config_path = os.path.join(os.path.dirname(__file__), config_file)
        with open(config_path, 'r') as f:
            return yaml.safe_load(f)
    
    def load_jenkinsfile(self) -> str:
        """Load Jenkinsfile content"""
        jenkinsfile_path = os.path.join(os.path.dirname(__file__), "Jenkinsfile")
        with open(jenkinsfile_path, 'r') as f:
            return f.read()
    
    def create_job_xml(self) -> str:
        """Create Jenkins job XML configuration"""
        # Load the Jenkinsfile content
        pipeline_script = self.load_jenkinsfile()
        
        # Create job XML configuration
        job_xml = f"""<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job@2.40">
  <actions>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobAction plugin="pipeline-model-definition@1.9.3"/>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition@1.9.3">
      <jobProperties/>
      <triggers/>
      <parameters>
        <string>CONTAINER_NAME</string>
        <string>CONTAINER_TYPE</string>
        <string>VERSION</string>
        <string>ACTION</string>
        <boolean>UPLOAD_TO_GDRIVE</boolean>
        <boolean>AUTO_START</boolean>
      </parameters>
      <options/>
    </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
  </actions>
  <description>Automated LXD Container Builder for Orchestrix&#xd;
&#xd;
This pipeline:&#xd;
- Creates LXD containers from configuration&#xd;
- Installs and configures software&#xd;
- Creates backups&#xd;
- Uploads to Google Drive&#xd;
&#xd;
Generated by AI Agent</description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <hudson.model.ParametersDefinitionProperty>
      <parameterDefinitions>
        <hudson.model.StringParameterDefinition>
          <name>CONTAINER_NAME</name>
          <description>Name of the container to build (e.g., mysql, redis, grafana)</description>
          <defaultValue></defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.ChoiceParameterDefinition>
          <name>CONTAINER_TYPE</name>
          <description>Type of container</description>
          <choices class="java.util.Arrays$ArrayList">
            <a class="string-array">
              <string>database</string>
              <string>cache</string>
              <string>monitoring</string>
              <string>web</string>
              <string>custom</string>
            </a>
          </choices>
        </hudson.model.ChoiceParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>VERSION</name>
          <description>Version of the software to install</description>
          <defaultValue>latest</defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.ChoiceParameterDefinition>
          <name>ACTION</name>
          <description>Action to perform</description>
          <choices class="java.util.Arrays$ArrayList">
            <a class="string-array">
              <string>create</string>
              <string>rebuild</string>
              <string>backup-only</string>
            </a>
          </choices>
        </hudson.model.ChoiceParameterDefinition>
        <hudson.model.BooleanParameterDefinition>
          <name>UPLOAD_TO_GDRIVE</name>
          <description>Upload backup to Google Drive</description>
          <defaultValue>true</defaultValue>
        </hudson.model.BooleanParameterDefinition>
        <hudson.model.BooleanParameterDefinition>
          <name>AUTO_START</name>
          <description>Start container after creation</description>
          <defaultValue>true</defaultValue>
        </hudson.model.BooleanParameterDefinition>
      </parameterDefinitions>
    </hudson.model.ParametersDefinitionProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@2.94">
    <script><![CDATA[{pipeline_script}]]></script>
    <sandbox>false</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>"""
        return job_xml
    
    def check_job_exists(self) -> bool:
        """Check if job already exists"""
        url = f"{self.jenkins_url}/job/{self.job_name}/api/json"
        try:
            response = requests.get(
                url,
                auth=(self.username, self.api_token),
                timeout=5
            )
            return response.status_code == 200
        except:
            return False
    
    def create_job(self) -> dict:
        """Create the Jenkins job"""
        # Check if job exists
        if self.check_job_exists():
            return {
                'success': False,
                'message': f'Job "{self.job_name}" already exists. Delete it first or use update.',
                'action': 'skip'
            }
        
        # Generate job XML
        job_xml = self.create_job_xml()
        
        # Create job URL
        create_url = f"{self.jenkins_url}/createItem"
        
        print(f"üì¶ Creating Jenkins job: {self.job_name}")
        print(f"üîó Jenkins URL: {self.jenkins_url}")
        
        try:
            response = requests.post(
                create_url,
                auth=(self.username, self.api_token),
                headers={'Content-Type': 'application/xml'},
                params={'name': self.job_name},
                data=job_xml.encode('utf-8'),
                timeout=10
            )
            
            if response.status_code in [200, 201]:
                return {
                    'success': True,
                    'message': f'Job "{self.job_name}" created successfully!',
                    'job_url': f"{self.jenkins_url}/job/{self.job_name}",
                    'config_url': f"{self.jenkins_url}/job/{self.job_name}/configure"
                }
            else:
                return {
                    'success': False,
                    'message': f'Failed to create job: HTTP {response.status_code}',
                    'response': response.text
                }
                
        except requests.exceptions.RequestException as e:
            return {
                'success': False,
                'message': f'Connection error: {str(e)}'
            }
    
    def update_job(self) -> dict:
        """Update existing Jenkins job"""
        if not self.check_job_exists():
            return {
                'success': False,
                'message': f'Job "{self.job_name}" does not exist. Use create instead.'
            }
        
        # Generate job XML
        job_xml = self.create_job_xml()
        
        # Update job URL
        update_url = f"{self.jenkins_url}/job/{self.job_name}/config.xml"
        
        print(f"üîÑ Updating Jenkins job: {self.job_name}")
        
        try:
            response = requests.post(
                update_url,
                auth=(self.username, self.api_token),
                headers={'Content-Type': 'application/xml'},
                data=job_xml.encode('utf-8'),
                timeout=10
            )
            
            if response.status_code == 200:
                return {
                    'success': True,
                    'message': f'Job "{self.job_name}" updated successfully!',
                    'job_url': f"{self.jenkins_url}/job/{self.job_name}"
                }
            else:
                return {
                    'success': False,
                    'message': f'Failed to update job: HTTP {response.status_code}',
                    'response': response.text
                }
                
        except requests.exceptions.RequestException as e:
            return {
                'success': False,
                'message': f'Connection error: {str(e)}'
            }
    
    def delete_job(self) -> dict:
        """Delete existing Jenkins job"""
        if not self.check_job_exists():
            return {
                'success': False,
                'message': f'Job "{self.job_name}" does not exist.'
            }
        
        delete_url = f"{self.jenkins_url}/job/{self.job_name}/doDelete"
        
        print(f"üóëÔ∏è Deleting Jenkins job: {self.job_name}")
        
        try:
            response = requests.post(
                delete_url,
                auth=(self.username, self.api_token),
                timeout=10
            )
            
            if response.status_code in [200, 201, 204, 302]:
                return {
                    'success': True,
                    'message': f'Job "{self.job_name}" deleted successfully!'
                }
            else:
                return {
                    'success': False,
                    'message': f'Failed to delete job: HTTP {response.status_code}'
                }
                
        except requests.exceptions.RequestException as e:
            return {
                'success': False,
                'message': f'Connection error: {str(e)}'
            }
    
    def copy_workspace_files(self) -> dict:
        """Copy container configuration files to Jenkins workspace"""
        print("üìÅ Preparing workspace files...")
        
        # Note: This would need to be run with appropriate permissions
        # or the files need to be in a Git repository that Jenkins can access
        
        commands = f"""
        # Create workspace directory if it doesn't exist
        sudo mkdir -p /var/lib/jenkins/workspace/{self.job_name}
        
        # Copy container configurations
        sudo cp -r containers /var/lib/jenkins/workspace/{self.job_name}/
        sudo cp -r jenkins /var/lib/jenkins/workspace/{self.job_name}/
        
        # Set permissions
        sudo chown -R jenkins:jenkins /var/lib/jenkins/workspace/{self.job_name}
        """
        
        return {
            'success': True,
            'message': 'Workspace files prepared',
            'note': 'Run these commands on Jenkins server:\n' + commands
        }

def main():
    """Main function"""
    if len(sys.argv) < 2:
        print("Usage: python create-jenkins-job.py [create|update|delete|check]")
        print("\nExamples:")
        print("  python create-jenkins-job.py create   # Create new job")
        print("  python create-jenkins-job.py update   # Update existing job")
        print("  python create-jenkins-job.py delete   # Delete job")
        print("  python create-jenkins-job.py check    # Check if job exists")
        sys.exit(1)
    
    action = sys.argv[1].lower()
    
    # Initialize creator
    creator = JenkinsJobCreator()
    
    # Perform action
    if action == "create":
        result = creator.create_job()
    elif action == "update":
        result = creator.update_job()
    elif action == "delete":
        result = creator.delete_job()
    elif action == "check":
        exists = creator.check_job_exists()
        result = {
            'success': True,
            'message': f"Job exists: {exists}",
            'exists': exists
        }
    else:
        print(f"Unknown action: {action}")
        sys.exit(1)
    
    # Display result
    if result['success']:
        print(f"‚úÖ {result['message']}")
        if 'job_url' in result:
            print(f"üîó Job URL: {result['job_url']}")
        if 'config_url' in result:
            print(f"‚öôÔ∏è Configure: {result['config_url']}")
        if 'note' in result:
            print(f"\nüìù Note: {result['note']}")
    else:
        print(f"‚ùå {result['message']}")
        if 'response' in result:
            print(f"Response: {result['response'][:500]}")
        sys.exit(1)

if __name__ == "__main__":
    main()