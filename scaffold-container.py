#!/usr/bin/env python3
"""
Scaffold Container with Jenkins Integration
This script creates a new container structure and sets up a Jenkins job to build it
"""

import os
import sys
import json
import yaml
import requests
import subprocess
import argparse
from pathlib import Path
from datetime import datetime
import xml.etree.ElementTree as ET

class ContainerScaffolder:
    def __init__(self, config_file='jenkins/jenkins-config.yml'):
        self.config = self.load_config(config_file)
        self.jenkins_url = self.config['jenkins']['server']['url']
        self.jenkins_user = self.config['jenkins']['auth']['username']
        self.jenkins_token = self.config['jenkins']['auth']['api_token']
        self.base_path = Path('/home/mustafa/telcobright-projects/orchestrix/images/lxc')
        
    def load_config(self, config_file):
        """Load Jenkins configuration"""
        config_path = Path(__file__).parent / config_file
        if not config_path.exists():
            print(f"❌ Config file not found: {config_path}")
            sys.exit(1)
        
        with open(config_path, 'r') as f:
            return yaml.safe_load(f)
    
    def scaffold_container(self, container_name, container_type='dev-env', base_os='debian/12'):
        """Create container directory structure and files"""
        print(f"🏗️ Scaffolding container: {container_name}")
        
        # Create directory
        container_dir = self.base_path / container_name
        container_dir.mkdir(parents=True, exist_ok=True)
        scripts_dir = container_dir / 'scripts'
        scripts_dir.mkdir(exist_ok=True)
        
        # Generate capitalized name for scripts
        cap_name = ''.join(word.capitalize() for word in container_name.split('-'))
        
        # Create build script
        self.create_build_script(container_dir, container_name, cap_name, base_os)
        
        # Create launch script
        self.create_launch_script(container_dir, container_name, cap_name)
        
        # Create config files
        self.create_config_files(container_dir, container_name, cap_name, container_type)
        
        # Create startDefault.sh
        self.create_start_default(container_dir, container_name, cap_name)
        
        # Create README
        self.create_readme(container_dir, container_name, container_type)
        
        # Create service scripts
        self.create_service_scripts(scripts_dir, container_name)
        
        print(f"✅ Container structure created at: {container_dir}")
        return container_dir
    
    def create_build_script(self, container_dir, container_name, cap_name, base_os):
        """Create build script"""
        os_name, os_version = base_os.split('/')
        
        build_script = f'''#!/bin/bash
# build{cap_name}.sh - Build {container_name} container
# Auto-generated by scaffold-container.py

set -e

# Colors
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
NC='\\033[0m'

# Load configuration
CONFIG_FILE="$(dirname "$0")/build{cap_name}Config.cnf"
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
else
    # Defaults
    CONTAINER_NAME="{container_name}"
    OS_NAME="{os_name}"
    OS_VERSION="{os_version}"
    ARCH="amd64"
fi

# Build timestamp
BUILD_TIMESTAMP=$(date +%Y%m%d-%H%M%S)

print_message() {{
    local color=$1
    local message=$2
    echo -e "${{color}}${{message}}${{NC}}"
}}

check_root() {{
    if [[ $EUID -ne 0 ]]; then
        print_message "$RED" "This script must be run as root"
        exit 1
    fi
}}

create_container() {{
    print_message "$YELLOW" "Creating container '${{CONTAINER_NAME}}' with ${{OS_NAME}} ${{OS_VERSION}}..."
    
    # Create container
    lxc launch ${{OS_NAME}}:${{OS_VERSION}} ${{CONTAINER_NAME}}
    
    # Wait for container
    sleep 10
    lxc exec ${{CONTAINER_NAME}} -- bash -c "until ping -c1 google.com &>/dev/null; do sleep 1; done"
    
    print_message "$GREEN" "Container created successfully!"
}}

install_packages() {{
    print_message "$YELLOW" "Installing packages..."
    
    lxc exec ${{CONTAINER_NAME}} -- bash -c "
        apt-get update
        apt-get install -y \\
            curl wget vim git \\
            build-essential \\
            openssh-client
    "
    
    print_message "$GREEN" "Packages installed!"
}}

setup_ssh_config() {{
    print_message "$YELLOW" "Setting up SSH configuration..."
    
    lxc exec ${{CONTAINER_NAME}} -- bash -c "
        mkdir -p /root/.ssh
        chmod 700 /root/.ssh
        
        cat > /root/.ssh/config << 'EOF'
Host *
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
    CheckHostIP no
    LogLevel ERROR
EOF
        chmod 600 /root/.ssh/config
    "
    
    print_message "$GREEN" "SSH configured!"
}}

create_base_image() {{
    print_message "$YELLOW" "Creating base image..."
    
    lxc stop ${{CONTAINER_NAME}}
    lxc publish ${{CONTAINER_NAME}} --alias {container_name}-base
    lxc delete ${{CONTAINER_NAME}}
    
    print_message "$GREEN" "Base image '{container_name}-base' created!"
}}

# Main
main() {{
    print_message "$GREEN" "=== {cap_name} Container Builder ==="
    
    check_root
    
    # Parse arguments
    OVERWRITE=false
    while [[ $# -gt 0 ]]; do
        case $1 in
            --overwrite)
                OVERWRITE=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Check if image exists
    if lxc image list --format=json | jq -r '.[].aliases[].name' | grep -q "^{container_name}-base$"; then
        if [ "$OVERWRITE" = true ]; then
            lxc image delete {container_name}-base
        else
            print_message "$YELLOW" "Image already exists. Use --overwrite to rebuild"
            exit 0
        fi
    fi
    
    create_container
    install_packages
    setup_ssh_config
    create_base_image
    
    print_message "$GREEN" "=== Build Complete ==="
}}

main "$@"
'''
        
        script_path = container_dir / f'build{cap_name}.sh'
        script_path.write_text(build_script)
        script_path.chmod(0o755)
        print(f"  ✅ Created: build{cap_name}.sh")
    
    def create_launch_script(self, container_dir, container_name, cap_name):
        """Create launch script"""
        launch_script = f'''#!/bin/bash
# launch{cap_name}.sh - Launch {container_name} container with config

set -e

# Colors
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
NC='\\033[0m'

DEFAULT_CONTAINER_NAME="{container_name}"
BASE_IMAGE="{container_name}-base"

print_message() {{
    local color=$1
    local message=$2
    echo -e "${{color}}${{message}}${{NC}}"
}}

# Check root
if [[ $EUID -ne 0 ]]; then
    print_message "$RED" "This script must be run as root"
    exit 1
fi

# Get config file
CONFIG_FILE="$1"
if [ ! -f "$CONFIG_FILE" ]; then
    print_message "$RED" "Config file not found: $CONFIG_FILE"
    exit 1
fi

print_message "$GREEN" "=== {cap_name} Container Launcher ==="

# Load config
source "$CONFIG_FILE"

# Check base image
if ! lxc image list --format=json | jq -r '.[].aliases[].name' | grep -q "^${{BASE_IMAGE}}$"; then
    print_message "$RED" "Base image not found. Run build{cap_name}.sh first"
    exit 1
fi

# Launch container
print_message "$YELLOW" "Launching container..."
lxc launch ${{BASE_IMAGE}} ${{CONTAINER_NAME:-$DEFAULT_CONTAINER_NAME}}

# Setup bind mounts
if [ -n "${{BIND_MOUNTS}}" ]; then
    print_message "$YELLOW" "Setting up bind mounts..."
    for MOUNT in "${{BIND_MOUNTS[@]}}"; do
        IFS=':' read -r HOST_PATH CONTAINER_PATH <<< "$MOUNT"
        echo "  Mounting $HOST_PATH -> $CONTAINER_PATH"
        # Add mount logic here
    done
fi

# Get IP
CONTAINER_IP=$(lxc list ${{CONTAINER_NAME}} --format=json | jq -r '.[0].state.network.eth0.addresses[] | select(.family=="inet").address' 2>/dev/null || echo "Not available")

print_message "$GREEN" "Container launched!"
print_message "$YELLOW" "Name: ${{CONTAINER_NAME}}"
print_message "$YELLOW" "IP: ${{CONTAINER_IP}}"
'''
        
        script_path = container_dir / f'launch{cap_name}.sh'
        script_path.write_text(launch_script)
        script_path.chmod(0o755)
        print(f"  ✅ Created: launch{cap_name}.sh")
    
    def create_config_files(self, container_dir, container_name, cap_name, container_type):
        """Create configuration files"""
        # Build config
        build_config = f'''# Build Configuration for {container_name}
CONTAINER_NAME="{container_name}"
OS_NAME="debian"
OS_VERSION="12"
ARCH="amd64"
'''
        (container_dir / f'build{cap_name}Config.cnf').write_text(build_config)
        print(f"  ✅ Created: build{cap_name}Config.cnf")
        
        # Sample runtime config
        sample_config = f'''#!/bin/bash
# Sample configuration for {container_name}

CONTAINER_NAME={container_name}

# Environment variables
CONTAINER_ENV_VARS=(
    "LOG_LEVEL=info"
    "ENVIRONMENT=development"
)

# Bind mounts (optional)
BIND_MOUNTS=(
    # "/host/path:/container/path"
)

# Container-specific settings
# Add your configuration here
'''
        (container_dir / 'sample-config.conf').write_text(sample_config)
        print(f"  ✅ Created: sample-config.conf")
    
    def create_start_default(self, container_dir, container_name, cap_name):
        """Create startDefault.sh"""
        start_script = f'''#!/bin/bash
# Quick start with defaults

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

if [[ $EUID -ne 0 ]]; then
    echo "This script must be run as root"
    exit 1
fi

echo "Starting {container_name} with defaults..."

# Build if needed
if ! lxc image list | grep -q "{container_name}-base"; then
    "${{SCRIPT_DIR}}/build{cap_name}.sh"
fi

# Launch with sample config
"${{SCRIPT_DIR}}/launch{cap_name}.sh" "${{SCRIPT_DIR}}/sample-config.conf"
'''
        
        script_path = container_dir / 'startDefault.sh'
        script_path.write_text(start_script)
        script_path.chmod(0o755)
        print(f"  ✅ Created: startDefault.sh")
    
    def create_readme(self, container_dir, container_name, container_type):
        """Create README"""
        readme = f'''# {container_name.replace('-', ' ').title()} Container

Type: {container_type}

## Quick Start

```bash
# Quick start with defaults
sudo ./startDefault.sh

# Or with custom config
sudo ./launch{container_name.replace('-', '').title()}.sh /path/to/config.conf
```

## Build

```bash
sudo ./build{container_name.replace('-', '').title()}.sh
```

## Files

- `build*.sh` - Build script
- `launch*.sh` - Launch script
- `sample-config.conf` - Sample configuration
- `startDefault.sh` - Quick start

## Jenkins

This container can be built via Jenkins job: {container_name}-builder
'''
        
        (container_dir / 'README.md').write_text(readme)
        print(f"  ✅ Created: README.md")
    
    def create_service_scripts(self, scripts_dir, container_name):
        """Create service management scripts"""
        service_script = f'''#!/bin/bash
# Service management for {container_name}

echo "Service manager for {container_name}"
# Add service management logic here
'''
        
        script_path = scripts_dir / f'{container_name}-services.sh'
        script_path.write_text(service_script)
        script_path.chmod(0o755)
        print(f"  ✅ Created: scripts/{container_name}-services.sh")
    
    def create_jenkins_job(self, container_name, container_type):
        """Create Jenkins job via API"""
        print(f"🔧 Creating Jenkins job for {container_name}...")
        
        job_name = f"{container_name}-builder"
        
        # Load pipeline template
        pipeline_path = Path(__file__).parent / 'jenkins' / 'container-pipeline-template.groovy'
        with open(pipeline_path, 'r') as f:
            pipeline_script = f.read()
        
        # Replace placeholders
        pipeline_script = pipeline_script.replace('${CONTAINER_NAME}', container_name)
        pipeline_script = pipeline_script.replace('${CONTAINER_TYPE}', container_type)
        
        # Create job XML
        job_xml = f'''<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job">
  <description>Build {container_name} container</description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <jenkins.model.BuildDiscarderProperty>
      <strategy class="hudson.tasks.LogRotator">
        <daysToKeep>30</daysToKeep>
        <numToKeep>10</numToKeep>
      </strategy>
    </jenkins.model.BuildDiscarderProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps">
    <script><![CDATA[{pipeline_script}]]></script>
    <sandbox>false</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>'''
        
        # Create job via API
        create_url = f"{self.jenkins_url}/createItem?name={job_name}"
        response = requests.post(
            create_url,
            auth=(self.jenkins_user, self.jenkins_token),
            headers={'Content-Type': 'application/xml'},
            data=job_xml
        )
        
        if response.status_code == 200:
            print(f"  ✅ Jenkins job created: {job_name}")
            print(f"  📎 URL: {self.jenkins_url}/job/{job_name}")
            return True
        else:
            print(f"  ❌ Failed to create Jenkins job: {response.status_code}")
            print(f"  Response: {response.text}")
            return False
    
    def check_jenkins_agent(self):
        """Check if Jenkins agent is running"""
        print("🔍 Checking Jenkins agent...")
        
        # Check agent status via API
        agents_url = f"{self.jenkins_url}/computer/api/json"
        try:
            response = requests.get(
                agents_url,
                auth=(self.jenkins_user, self.jenkins_token)
            )
            
            if response.status_code == 200:
                data = response.json()
                for computer in data['computer']:
                    if 'lxd-build-agent' in computer['displayName'].lower():
                        if computer['offline']:
                            print("  ⚠️ LXD build agent is offline")
                            self.start_jenkins_agent()
                        else:
                            print("  ✅ LXD build agent is online")
                        return
                
                print("  ⚠️ No LXD build agent found")
                self.setup_jenkins_agent()
            else:
                print(f"  ❌ Failed to check agents: {response.status_code}")
        except Exception as e:
            print(f"  ❌ Error checking agents: {e}")
    
    def start_jenkins_agent(self):
        """Start Jenkins agent"""
        print("  🚀 Starting Jenkins agent...")
        
        # Use the existing setup script
        setup_script = Path(__file__).parent / 'jenkins' / 'setup-jenkins-agent.sh'
        if setup_script.exists():
            result = subprocess.run(['sudo', str(setup_script), 'start'], capture_output=True, text=True)
            if result.returncode == 0:
                print("  ✅ Jenkins agent started")
            else:
                print(f"  ❌ Failed to start agent: {result.stderr}")
        else:
            print("  ❌ Agent setup script not found")
    
    def setup_jenkins_agent(self):
        """Setup new Jenkins agent"""
        print("  🔧 Setting up new Jenkins agent...")
        print("  Please run: sudo jenkins/setup-jenkins-agent.sh")
    
    def trigger_build(self, container_name):
        """Trigger Jenkins build"""
        print(f"🚀 Triggering build for {container_name}...")
        
        job_name = f"{container_name}-builder"
        build_url = f"{self.jenkins_url}/job/{job_name}/build"
        
        response = requests.post(
            build_url,
            auth=(self.jenkins_user, self.jenkins_token)
        )
        
        if response.status_code in [200, 201]:
            print(f"  ✅ Build triggered successfully")
            print(f"  📎 Monitor at: {self.jenkins_url}/job/{job_name}")
        else:
            print(f"  ❌ Failed to trigger build: {response.status_code}")

def main():
    parser = argparse.ArgumentParser(description='Scaffold LXC container with Jenkins integration')
    parser.add_argument('container_name', help='Name of the container (e.g., postgres-dev)')
    parser.add_argument('--type', default='dev-env', choices=['dev-env', 'service', 'test'],
                       help='Type of container')
    parser.add_argument('--os', default='debian/12', help='Base OS (e.g., debian/12, ubuntu/22.04)')
    parser.add_argument('--no-jenkins', action='store_true', help='Skip Jenkins job creation')
    parser.add_argument('--trigger-build', action='store_true', help='Trigger build after creation')
    
    args = parser.parse_args()
    
    # Validate container name
    if not args.container_name.replace('-', '').replace('_', '').isalnum():
        print("❌ Invalid container name. Use only letters, numbers, hyphens, and underscores.")
        sys.exit(1)
    
    scaffolder = ContainerScaffolder()
    
    print(f"🏗️ Scaffolding container: {args.container_name}")
    print(f"  Type: {args.type}")
    print(f"  Base OS: {args.os}")
    print("")
    
    # Create container structure
    container_dir = scaffolder.scaffold_container(args.container_name, args.type, args.os)
    
    if not args.no_jenkins:
        # Check Jenkins agent
        scaffolder.check_jenkins_agent()
        
        # Create Jenkins job
        if scaffolder.create_jenkins_job(args.container_name, args.type):
            
            if args.trigger_build:
                # Trigger build
                scaffolder.trigger_build(args.container_name)
    
    print("")
    print("✅ Scaffolding complete!")
    print("")
    print("Next steps:")
    print(f"  1. cd {container_dir}")
    print(f"  2. Edit configuration as needed")
    print(f"  3. Build via Jenkins: {scaffolder.jenkins_url}/job/{args.container_name}-builder")
    print(f"  Or build locally: sudo ./build*.sh")

if __name__ == '__main__':
    main()